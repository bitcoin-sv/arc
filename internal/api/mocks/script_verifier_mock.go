// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/bitcoin-sv/arc/internal/api"
	"github.com/bitcoin-sv/bdk/module/gobdk/script"
	"sync"
)

// Ensure, that ScriptVerifierMock does implement api.ScriptVerifier.
// If this is not the case, regenerate this file with moq.
var _ api.ScriptVerifier = &ScriptVerifierMock{}

// ScriptVerifierMock is a mock implementation of api.ScriptVerifier.
//
//	func TestSomethingThatUsesScriptVerifier(t *testing.T) {
//
//		// make and configure a mocked api.ScriptVerifier
//		mockedScriptVerifier := &ScriptVerifierMock{
//			VerifyScriptFunc: func(extendedTX []byte, utxoHeights []int32, blockHeight int32, consensus bool) script.ScriptError {
//				panic("mock out the VerifyScript method")
//			},
//		}
//
//		// use mockedScriptVerifier in code that requires api.ScriptVerifier
//		// and then make assertions.
//
//	}
type ScriptVerifierMock struct {
	// VerifyScriptFunc mocks the VerifyScript method.
	VerifyScriptFunc func(extendedTX []byte, utxoHeights []int32, blockHeight int32, consensus bool) script.ScriptError

	// calls tracks calls to the methods.
	calls struct {
		// VerifyScript holds details about calls to the VerifyScript method.
		VerifyScript []struct {
			// ExtendedTX is the extendedTX argument value.
			ExtendedTX []byte
			// UtxoHeights is the utxoHeights argument value.
			UtxoHeights []int32
			// BlockHeight is the blockHeight argument value.
			BlockHeight int32
			// Consensus is the consensus argument value.
			Consensus bool
		}
	}
	lockVerifyScript sync.RWMutex
}

// VerifyScript calls VerifyScriptFunc.
func (mock *ScriptVerifierMock) VerifyScript(extendedTX []byte, utxoHeights []int32, blockHeight int32, consensus bool) script.ScriptError {
	if mock.VerifyScriptFunc == nil {
		panic("ScriptVerifierMock.VerifyScriptFunc: method is nil but ScriptVerifier.VerifyScript was just called")
	}
	callInfo := struct {
		ExtendedTX  []byte
		UtxoHeights []int32
		BlockHeight int32
		Consensus   bool
	}{
		ExtendedTX:  extendedTX,
		UtxoHeights: utxoHeights,
		BlockHeight: blockHeight,
		Consensus:   consensus,
	}
	mock.lockVerifyScript.Lock()
	mock.calls.VerifyScript = append(mock.calls.VerifyScript, callInfo)
	mock.lockVerifyScript.Unlock()
	return mock.VerifyScriptFunc(extendedTX, utxoHeights, blockHeight, consensus)
}

// VerifyScriptCalls gets all the calls that were made to VerifyScript.
// Check the length with:
//
//	len(mockedScriptVerifier.VerifyScriptCalls())
func (mock *ScriptVerifierMock) VerifyScriptCalls() []struct {
	ExtendedTX  []byte
	UtxoHeights []int32
	BlockHeight int32
	Consensus   bool
} {
	var calls []struct {
		ExtendedTX  []byte
		UtxoHeights []int32
		BlockHeight int32
		Consensus   bool
	}
	mock.lockVerifyScript.RLock()
	calls = mock.calls.VerifyScript
	mock.lockVerifyScript.RUnlock()
	return calls
}

// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/bitcoin-sv/arc/internal/broadcaster"
	sdkTx "github.com/bsv-blockchain/go-sdk/transaction"
	"sync"
	"time"
)

// Ensure, that UtxoClientMock does implement broadcaster.UtxoClient.
// If this is not the case, regenerate this file with moq.
var _ broadcaster.UtxoClient = &UtxoClientMock{}

// UtxoClientMock is a mock implementation of broadcaster.UtxoClient.
//
//	func TestSomethingThatUsesUtxoClient(t *testing.T) {
//
//		// make and configure a mocked broadcaster.UtxoClient
//		mockedUtxoClient := &UtxoClientMock{
//			GetBalanceFunc: func(ctx context.Context, address string) (uint64, uint64, error) {
//				panic("mock out the GetBalance method")
//			},
//			GetBalanceWithRetriesFunc: func(ctx context.Context, address string, constantBackoff time.Duration, retries uint64) (uint64, uint64, error) {
//				panic("mock out the GetBalanceWithRetries method")
//			},
//			GetLimitedUTXOsWithRetriesFunc: func(ctx context.Context, address string, constantBackoff time.Duration, retries uint64, utxosCount int) (sdkTx.UTXOs, error) {
//				panic("mock out the GetLimitedUTXOsWithRetries method")
//			},
//			GetUTXOsFunc: func(ctx context.Context, address string) (sdkTx.UTXOs, error) {
//				panic("mock out the GetUTXOs method")
//			},
//			GetUTXOsWithRetriesFunc: func(ctx context.Context, address string, constantBackoff time.Duration, retries uint64) (sdkTx.UTXOs, error) {
//				panic("mock out the GetUTXOsWithRetries method")
//			},
//			TopUpFunc: func(ctx context.Context, address string) error {
//				panic("mock out the TopUp method")
//			},
//		}
//
//		// use mockedUtxoClient in code that requires broadcaster.UtxoClient
//		// and then make assertions.
//
//	}
type UtxoClientMock struct {
	// GetBalanceFunc mocks the GetBalance method.
	GetBalanceFunc func(ctx context.Context, address string) (uint64, uint64, error)

	// GetBalanceWithRetriesFunc mocks the GetBalanceWithRetries method.
	GetBalanceWithRetriesFunc func(ctx context.Context, address string, constantBackoff time.Duration, retries uint64) (uint64, uint64, error)

	// GetLimitedUTXOsWithRetriesFunc mocks the GetLimitedUTXOsWithRetries method.
	GetLimitedUTXOsWithRetriesFunc func(ctx context.Context, address string, constantBackoff time.Duration, retries uint64, utxosCount int) (sdkTx.UTXOs, error)

	// GetUTXOsFunc mocks the GetUTXOs method.
	GetUTXOsFunc func(ctx context.Context, address string) (sdkTx.UTXOs, error)

	// GetUTXOsWithRetriesFunc mocks the GetUTXOsWithRetries method.
	GetUTXOsWithRetriesFunc func(ctx context.Context, address string, constantBackoff time.Duration, retries uint64) (sdkTx.UTXOs, error)

	// TopUpFunc mocks the TopUp method.
	TopUpFunc func(ctx context.Context, address string) error

	// calls tracks calls to the methods.
	calls struct {
		// GetBalance holds details about calls to the GetBalance method.
		GetBalance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address string
		}
		// GetBalanceWithRetries holds details about calls to the GetBalanceWithRetries method.
		GetBalanceWithRetries []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address string
			// ConstantBackoff is the constantBackoff argument value.
			ConstantBackoff time.Duration
			// Retries is the retries argument value.
			Retries uint64
		}
		// GetLimitedUTXOsWithRetries holds details about calls to the GetLimitedUTXOsWithRetries method.
		GetLimitedUTXOsWithRetries []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address string
			// ConstantBackoff is the constantBackoff argument value.
			ConstantBackoff time.Duration
			// Retries is the retries argument value.
			Retries uint64
			// UtxosCount is the utxosCount argument value.
			UtxosCount int
		}
		// GetUTXOs holds details about calls to the GetUTXOs method.
		GetUTXOs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address string
		}
		// GetUTXOsWithRetries holds details about calls to the GetUTXOsWithRetries method.
		GetUTXOsWithRetries []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address string
			// ConstantBackoff is the constantBackoff argument value.
			ConstantBackoff time.Duration
			// Retries is the retries argument value.
			Retries uint64
		}
		// TopUp holds details about calls to the TopUp method.
		TopUp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address string
		}
	}
	lockGetBalance                 sync.RWMutex
	lockGetBalanceWithRetries      sync.RWMutex
	lockGetLimitedUTXOsWithRetries sync.RWMutex
	lockGetUTXOs                   sync.RWMutex
	lockGetUTXOsWithRetries        sync.RWMutex
	lockTopUp                      sync.RWMutex
}

// GetBalance calls GetBalanceFunc.
func (mock *UtxoClientMock) GetBalance(ctx context.Context, address string) (uint64, uint64, error) {
	if mock.GetBalanceFunc == nil {
		panic("UtxoClientMock.GetBalanceFunc: method is nil but UtxoClient.GetBalance was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Address string
	}{
		Ctx:     ctx,
		Address: address,
	}
	mock.lockGetBalance.Lock()
	mock.calls.GetBalance = append(mock.calls.GetBalance, callInfo)
	mock.lockGetBalance.Unlock()
	return mock.GetBalanceFunc(ctx, address)
}

// GetBalanceCalls gets all the calls that were made to GetBalance.
// Check the length with:
//
//	len(mockedUtxoClient.GetBalanceCalls())
func (mock *UtxoClientMock) GetBalanceCalls() []struct {
	Ctx     context.Context
	Address string
} {
	var calls []struct {
		Ctx     context.Context
		Address string
	}
	mock.lockGetBalance.RLock()
	calls = mock.calls.GetBalance
	mock.lockGetBalance.RUnlock()
	return calls
}

// GetBalanceWithRetries calls GetBalanceWithRetriesFunc.
func (mock *UtxoClientMock) GetBalanceWithRetries(ctx context.Context, address string, constantBackoff time.Duration, retries uint64) (uint64, uint64, error) {
	if mock.GetBalanceWithRetriesFunc == nil {
		panic("UtxoClientMock.GetBalanceWithRetriesFunc: method is nil but UtxoClient.GetBalanceWithRetries was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		Address         string
		ConstantBackoff time.Duration
		Retries         uint64
	}{
		Ctx:             ctx,
		Address:         address,
		ConstantBackoff: constantBackoff,
		Retries:         retries,
	}
	mock.lockGetBalanceWithRetries.Lock()
	mock.calls.GetBalanceWithRetries = append(mock.calls.GetBalanceWithRetries, callInfo)
	mock.lockGetBalanceWithRetries.Unlock()
	return mock.GetBalanceWithRetriesFunc(ctx, address, constantBackoff, retries)
}

// GetBalanceWithRetriesCalls gets all the calls that were made to GetBalanceWithRetries.
// Check the length with:
//
//	len(mockedUtxoClient.GetBalanceWithRetriesCalls())
func (mock *UtxoClientMock) GetBalanceWithRetriesCalls() []struct {
	Ctx             context.Context
	Address         string
	ConstantBackoff time.Duration
	Retries         uint64
} {
	var calls []struct {
		Ctx             context.Context
		Address         string
		ConstantBackoff time.Duration
		Retries         uint64
	}
	mock.lockGetBalanceWithRetries.RLock()
	calls = mock.calls.GetBalanceWithRetries
	mock.lockGetBalanceWithRetries.RUnlock()
	return calls
}

// GetLimitedUTXOsWithRetries calls GetLimitedUTXOsWithRetriesFunc.
func (mock *UtxoClientMock) GetLimitedUTXOsWithRetries(ctx context.Context, address string, constantBackoff time.Duration, retries uint64, utxosCount int) (sdkTx.UTXOs, error) {
	if mock.GetLimitedUTXOsWithRetriesFunc == nil {
		panic("UtxoClientMock.GetLimitedUTXOsWithRetriesFunc: method is nil but UtxoClient.GetLimitedUTXOsWithRetries was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		Address         string
		ConstantBackoff time.Duration
		Retries         uint64
		UtxosCount      int
	}{
		Ctx:             ctx,
		Address:         address,
		ConstantBackoff: constantBackoff,
		Retries:         retries,
		UtxosCount:      utxosCount,
	}
	mock.lockGetLimitedUTXOsWithRetries.Lock()
	mock.calls.GetLimitedUTXOsWithRetries = append(mock.calls.GetLimitedUTXOsWithRetries, callInfo)
	mock.lockGetLimitedUTXOsWithRetries.Unlock()
	return mock.GetLimitedUTXOsWithRetriesFunc(ctx, address, constantBackoff, retries, utxosCount)
}

// GetLimitedUTXOsWithRetriesCalls gets all the calls that were made to GetLimitedUTXOsWithRetries.
// Check the length with:
//
//	len(mockedUtxoClient.GetLimitedUTXOsWithRetriesCalls())
func (mock *UtxoClientMock) GetLimitedUTXOsWithRetriesCalls() []struct {
	Ctx             context.Context
	Address         string
	ConstantBackoff time.Duration
	Retries         uint64
	UtxosCount      int
} {
	var calls []struct {
		Ctx             context.Context
		Address         string
		ConstantBackoff time.Duration
		Retries         uint64
		UtxosCount      int
	}
	mock.lockGetLimitedUTXOsWithRetries.RLock()
	calls = mock.calls.GetLimitedUTXOsWithRetries
	mock.lockGetLimitedUTXOsWithRetries.RUnlock()
	return calls
}

// GetUTXOs calls GetUTXOsFunc.
func (mock *UtxoClientMock) GetUTXOs(ctx context.Context, address string) (sdkTx.UTXOs, error) {
	if mock.GetUTXOsFunc == nil {
		panic("UtxoClientMock.GetUTXOsFunc: method is nil but UtxoClient.GetUTXOs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Address string
	}{
		Ctx:     ctx,
		Address: address,
	}
	mock.lockGetUTXOs.Lock()
	mock.calls.GetUTXOs = append(mock.calls.GetUTXOs, callInfo)
	mock.lockGetUTXOs.Unlock()
	return mock.GetUTXOsFunc(ctx, address)
}

// GetUTXOsCalls gets all the calls that were made to GetUTXOs.
// Check the length with:
//
//	len(mockedUtxoClient.GetUTXOsCalls())
func (mock *UtxoClientMock) GetUTXOsCalls() []struct {
	Ctx     context.Context
	Address string
} {
	var calls []struct {
		Ctx     context.Context
		Address string
	}
	mock.lockGetUTXOs.RLock()
	calls = mock.calls.GetUTXOs
	mock.lockGetUTXOs.RUnlock()
	return calls
}

// GetUTXOsWithRetries calls GetUTXOsWithRetriesFunc.
func (mock *UtxoClientMock) GetUTXOsWithRetries(ctx context.Context, address string, constantBackoff time.Duration, retries uint64) (sdkTx.UTXOs, error) {
	if mock.GetUTXOsWithRetriesFunc == nil {
		panic("UtxoClientMock.GetUTXOsWithRetriesFunc: method is nil but UtxoClient.GetUTXOsWithRetries was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		Address         string
		ConstantBackoff time.Duration
		Retries         uint64
	}{
		Ctx:             ctx,
		Address:         address,
		ConstantBackoff: constantBackoff,
		Retries:         retries,
	}
	mock.lockGetUTXOsWithRetries.Lock()
	mock.calls.GetUTXOsWithRetries = append(mock.calls.GetUTXOsWithRetries, callInfo)
	mock.lockGetUTXOsWithRetries.Unlock()
	return mock.GetUTXOsWithRetriesFunc(ctx, address, constantBackoff, retries)
}

// GetUTXOsWithRetriesCalls gets all the calls that were made to GetUTXOsWithRetries.
// Check the length with:
//
//	len(mockedUtxoClient.GetUTXOsWithRetriesCalls())
func (mock *UtxoClientMock) GetUTXOsWithRetriesCalls() []struct {
	Ctx             context.Context
	Address         string
	ConstantBackoff time.Duration
	Retries         uint64
} {
	var calls []struct {
		Ctx             context.Context
		Address         string
		ConstantBackoff time.Duration
		Retries         uint64
	}
	mock.lockGetUTXOsWithRetries.RLock()
	calls = mock.calls.GetUTXOsWithRetries
	mock.lockGetUTXOsWithRetries.RUnlock()
	return calls
}

// TopUp calls TopUpFunc.
func (mock *UtxoClientMock) TopUp(ctx context.Context, address string) error {
	if mock.TopUpFunc == nil {
		panic("UtxoClientMock.TopUpFunc: method is nil but UtxoClient.TopUp was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Address string
	}{
		Ctx:     ctx,
		Address: address,
	}
	mock.lockTopUp.Lock()
	mock.calls.TopUp = append(mock.calls.TopUp, callInfo)
	mock.lockTopUp.Unlock()
	return mock.TopUpFunc(ctx, address)
}

// TopUpCalls gets all the calls that were made to TopUp.
// Check the length with:
//
//	len(mockedUtxoClient.TopUpCalls())
func (mock *UtxoClientMock) TopUpCalls() []struct {
	Ctx     context.Context
	Address string
} {
	var calls []struct {
		Ctx     context.Context
		Address string
	}
	mock.lockTopUp.RLock()
	calls = mock.calls.TopUp
	mock.lockTopUp.RUnlock()
	return calls
}

// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/bitcoin-sv/arc/internal/callbacker/store"
	"sync"
	"time"
)

// Ensure, that ProcessorStoreMock does implement store.ProcessorStore.
// If this is not the case, regenerate this file with moq.
var _ store.ProcessorStore = &ProcessorStoreMock{}

// ProcessorStoreMock is a mock implementation of store.ProcessorStore.
//
//	func TestSomethingThatUsesProcessorStore(t *testing.T) {
//
//		// make and configure a mocked store.ProcessorStore
//		mockedProcessorStore := &ProcessorStoreMock{
//			ClearFunc: func(ctx context.Context, t time.Time) error {
//				panic("mock out the Clear method")
//			},
//			GetUnsentFunc: func(ctx context.Context, limit int, expiration time.Duration, batch bool) ([]*store.CallbackData, error) {
//				panic("mock out the GetUnsent method")
//			},
//			InsertFunc: func(ctx context.Context, data []*store.CallbackData) (int64, error) {
//				panic("mock out the Insert method")
//			},
//			SetSentFunc: func(ctx context.Context, ids []int64) error {
//				panic("mock out the SetSent method")
//			},
//			UnsetPendingFunc: func(ctx context.Context, ids []int64) error {
//				panic("mock out the UnsetPending method")
//			},
//		}
//
//		// use mockedProcessorStore in code that requires store.ProcessorStore
//		// and then make assertions.
//
//	}
type ProcessorStoreMock struct {
	// ClearFunc mocks the Clear method.
	ClearFunc func(ctx context.Context, t time.Time) error

	// GetUnsentFunc mocks the GetUnsent method.
	GetUnsentFunc func(ctx context.Context, limit int, expiration time.Duration, batch bool) ([]*store.CallbackData, error)

	// InsertFunc mocks the Insert method.
	InsertFunc func(ctx context.Context, data []*store.CallbackData) (int64, error)

	// SetSentFunc mocks the SetSent method.
	SetSentFunc func(ctx context.Context, ids []int64) error

	// UnsetPendingFunc mocks the UnsetPending method.
	UnsetPendingFunc func(ctx context.Context, ids []int64) error

	// calls tracks calls to the methods.
	calls struct {
		// Clear holds details about calls to the Clear method.
		Clear []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// T is the t argument value.
			T time.Time
		}
		// GetUnsent holds details about calls to the GetUnsent method.
		GetUnsent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Limit is the limit argument value.
			Limit int
			// Expiration is the expiration argument value.
			Expiration time.Duration
			// Batch is the batch argument value.
			Batch bool
		}
		// Insert holds details about calls to the Insert method.
		Insert []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Data is the data argument value.
			Data []*store.CallbackData
		}
		// SetSent holds details about calls to the SetSent method.
		SetSent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ids is the ids argument value.
			Ids []int64
		}
		// UnsetPending holds details about calls to the UnsetPending method.
		UnsetPending []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ids is the ids argument value.
			Ids []int64
		}
	}
	lockClear        sync.RWMutex
	lockGetUnsent    sync.RWMutex
	lockInsert       sync.RWMutex
	lockSetSent      sync.RWMutex
	lockUnsetPending sync.RWMutex
}

// Clear calls ClearFunc.
func (mock *ProcessorStoreMock) Clear(ctx context.Context, t time.Time) error {
	if mock.ClearFunc == nil {
		panic("ProcessorStoreMock.ClearFunc: method is nil but ProcessorStore.Clear was just called")
	}
	callInfo := struct {
		Ctx context.Context
		T   time.Time
	}{
		Ctx: ctx,
		T:   t,
	}
	mock.lockClear.Lock()
	mock.calls.Clear = append(mock.calls.Clear, callInfo)
	mock.lockClear.Unlock()
	return mock.ClearFunc(ctx, t)
}

// ClearCalls gets all the calls that were made to Clear.
// Check the length with:
//
//	len(mockedProcessorStore.ClearCalls())
func (mock *ProcessorStoreMock) ClearCalls() []struct {
	Ctx context.Context
	T   time.Time
} {
	var calls []struct {
		Ctx context.Context
		T   time.Time
	}
	mock.lockClear.RLock()
	calls = mock.calls.Clear
	mock.lockClear.RUnlock()
	return calls
}

// GetUnsent calls GetUnsentFunc.
func (mock *ProcessorStoreMock) GetUnsent(ctx context.Context, limit int, expiration time.Duration, batch bool) ([]*store.CallbackData, error) {
	if mock.GetUnsentFunc == nil {
		panic("ProcessorStoreMock.GetUnsentFunc: method is nil but ProcessorStore.GetUnsent was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Limit      int
		Expiration time.Duration
		Batch      bool
	}{
		Ctx:        ctx,
		Limit:      limit,
		Expiration: expiration,
		Batch:      batch,
	}
	mock.lockGetUnsent.Lock()
	mock.calls.GetUnsent = append(mock.calls.GetUnsent, callInfo)
	mock.lockGetUnsent.Unlock()
	return mock.GetUnsentFunc(ctx, limit, expiration, batch)
}

// GetUnsentCalls gets all the calls that were made to GetUnsent.
// Check the length with:
//
//	len(mockedProcessorStore.GetUnsentCalls())
func (mock *ProcessorStoreMock) GetUnsentCalls() []struct {
	Ctx        context.Context
	Limit      int
	Expiration time.Duration
	Batch      bool
} {
	var calls []struct {
		Ctx        context.Context
		Limit      int
		Expiration time.Duration
		Batch      bool
	}
	mock.lockGetUnsent.RLock()
	calls = mock.calls.GetUnsent
	mock.lockGetUnsent.RUnlock()
	return calls
}

// Insert calls InsertFunc.
func (mock *ProcessorStoreMock) Insert(ctx context.Context, data []*store.CallbackData) (int64, error) {
	if mock.InsertFunc == nil {
		panic("ProcessorStoreMock.InsertFunc: method is nil but ProcessorStore.Insert was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Data []*store.CallbackData
	}{
		Ctx:  ctx,
		Data: data,
	}
	mock.lockInsert.Lock()
	mock.calls.Insert = append(mock.calls.Insert, callInfo)
	mock.lockInsert.Unlock()
	return mock.InsertFunc(ctx, data)
}

// InsertCalls gets all the calls that were made to Insert.
// Check the length with:
//
//	len(mockedProcessorStore.InsertCalls())
func (mock *ProcessorStoreMock) InsertCalls() []struct {
	Ctx  context.Context
	Data []*store.CallbackData
} {
	var calls []struct {
		Ctx  context.Context
		Data []*store.CallbackData
	}
	mock.lockInsert.RLock()
	calls = mock.calls.Insert
	mock.lockInsert.RUnlock()
	return calls
}

// SetSent calls SetSentFunc.
func (mock *ProcessorStoreMock) SetSent(ctx context.Context, ids []int64) error {
	if mock.SetSentFunc == nil {
		panic("ProcessorStoreMock.SetSentFunc: method is nil but ProcessorStore.SetSent was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Ids []int64
	}{
		Ctx: ctx,
		Ids: ids,
	}
	mock.lockSetSent.Lock()
	mock.calls.SetSent = append(mock.calls.SetSent, callInfo)
	mock.lockSetSent.Unlock()
	return mock.SetSentFunc(ctx, ids)
}

// SetSentCalls gets all the calls that were made to SetSent.
// Check the length with:
//
//	len(mockedProcessorStore.SetSentCalls())
func (mock *ProcessorStoreMock) SetSentCalls() []struct {
	Ctx context.Context
	Ids []int64
} {
	var calls []struct {
		Ctx context.Context
		Ids []int64
	}
	mock.lockSetSent.RLock()
	calls = mock.calls.SetSent
	mock.lockSetSent.RUnlock()
	return calls
}

// UnsetPending calls UnsetPendingFunc.
func (mock *ProcessorStoreMock) UnsetPending(ctx context.Context, ids []int64) error {
	if mock.UnsetPendingFunc == nil {
		panic("ProcessorStoreMock.UnsetPendingFunc: method is nil but ProcessorStore.UnsetPending was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Ids []int64
	}{
		Ctx: ctx,
		Ids: ids,
	}
	mock.lockUnsetPending.Lock()
	mock.calls.UnsetPending = append(mock.calls.UnsetPending, callInfo)
	mock.lockUnsetPending.Unlock()
	return mock.UnsetPendingFunc(ctx, ids)
}

// UnsetPendingCalls gets all the calls that were made to UnsetPending.
// Check the length with:
//
//	len(mockedProcessorStore.UnsetPendingCalls())
func (mock *ProcessorStoreMock) UnsetPendingCalls() []struct {
	Ctx context.Context
	Ids []int64
} {
	var calls []struct {
		Ctx context.Context
		Ids []int64
	}
	mock.lockUnsetPending.RLock()
	calls = mock.calls.UnsetPending
	mock.lockUnsetPending.RUnlock()
	return calls
}

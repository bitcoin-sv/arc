// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/bitcoin-sv/arc/internal/callbacker"
	"sync"
)

// Ensure, that SendManagerIMock does implement callbacker.SendManagerI.
// If this is not the case, regenerate this file with moq.
var _ callbacker.SendManagerI = &SendManagerIMock{}

// SendManagerIMock is a mock implementation of callbacker.SendManagerI.
//
//	func TestSomethingThatUsesSendManagerI(t *testing.T) {
//
//		// make and configure a mocked callbacker.SendManagerI
//		mockedSendManagerI := &SendManagerIMock{
//			EnqueueFunc: func(entry callbacker.CallbackEntry)  {
//				panic("mock out the Enqueue method")
//			},
//			GracefulStopFunc: func()  {
//				panic("mock out the GracefulStop method")
//			},
//			StartFunc: func()  {
//				panic("mock out the Start method")
//			},
//		}
//
//		// use mockedSendManagerI in code that requires callbacker.SendManagerI
//		// and then make assertions.
//
//	}
type SendManagerIMock struct {
	// EnqueueFunc mocks the Enqueue method.
	EnqueueFunc func(entry callbacker.CallbackEntry)

	// GracefulStopFunc mocks the GracefulStop method.
	GracefulStopFunc func()

	// StartFunc mocks the Start method.
	StartFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// Enqueue holds details about calls to the Enqueue method.
		Enqueue []struct {
			// Entry is the entry argument value.
			Entry callbacker.CallbackEntry
		}
		// GracefulStop holds details about calls to the GracefulStop method.
		GracefulStop []struct {
		}
		// Start holds details about calls to the Start method.
		Start []struct {
		}
	}
	lockEnqueue      sync.RWMutex
	lockGracefulStop sync.RWMutex
	lockStart        sync.RWMutex
}

// Enqueue calls EnqueueFunc.
func (mock *SendManagerIMock) Enqueue(entry callbacker.CallbackEntry) {
	if mock.EnqueueFunc == nil {
		panic("SendManagerIMock.EnqueueFunc: method is nil but SendManagerI.Enqueue was just called")
	}
	callInfo := struct {
		Entry callbacker.CallbackEntry
	}{
		Entry: entry,
	}
	mock.lockEnqueue.Lock()
	mock.calls.Enqueue = append(mock.calls.Enqueue, callInfo)
	mock.lockEnqueue.Unlock()
	mock.EnqueueFunc(entry)
}

// EnqueueCalls gets all the calls that were made to Enqueue.
// Check the length with:
//
//	len(mockedSendManagerI.EnqueueCalls())
func (mock *SendManagerIMock) EnqueueCalls() []struct {
	Entry callbacker.CallbackEntry
} {
	var calls []struct {
		Entry callbacker.CallbackEntry
	}
	mock.lockEnqueue.RLock()
	calls = mock.calls.Enqueue
	mock.lockEnqueue.RUnlock()
	return calls
}

// GracefulStop calls GracefulStopFunc.
func (mock *SendManagerIMock) GracefulStop() {
	if mock.GracefulStopFunc == nil {
		panic("SendManagerIMock.GracefulStopFunc: method is nil but SendManagerI.GracefulStop was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGracefulStop.Lock()
	mock.calls.GracefulStop = append(mock.calls.GracefulStop, callInfo)
	mock.lockGracefulStop.Unlock()
	mock.GracefulStopFunc()
}

// GracefulStopCalls gets all the calls that were made to GracefulStop.
// Check the length with:
//
//	len(mockedSendManagerI.GracefulStopCalls())
func (mock *SendManagerIMock) GracefulStopCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGracefulStop.RLock()
	calls = mock.calls.GracefulStop
	mock.lockGracefulStop.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *SendManagerIMock) Start() {
	if mock.StartFunc == nil {
		panic("SendManagerIMock.StartFunc: method is nil but SendManagerI.Start was just called")
	}
	callInfo := struct {
	}{}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	mock.StartFunc()
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedSendManagerI.StartCalls())
func (mock *SendManagerIMock) StartCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

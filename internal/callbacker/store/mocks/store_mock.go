// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/bitcoin-sv/arc/internal/blocktx/blocktx_api"
	"github.com/bitcoin-sv/arc/internal/callbacker"
	"github.com/bitcoin-sv/arc/internal/callbacker/store"
	"github.com/libsv/go-p2p/chaincfg/chainhash"
	"sync"
	"time"
)

// Ensure, that CallbackerStoreMock does implement store.CallbackerStore.
// If this is not the case, regenerate this file with moq.
var _ store.CallbackStore = &CallbackerStoreMock{}

// CallbackerStoreMock is a mock implementation of store.CallbackerStore.
//
//	func TestSomethingThatUsesCallbackerStore(t *testing.T) {
//
//		// make and configure a mocked store.CallbackerStore
//		mockedCallbackerStore := &CallbackerStoreMock{
//			ClearDataFunc: func(ctx context.Context, retentionDays int32) (int64, error) {
//				panic("mock out the ClearData method")
//			},
//			CloseFunc: func(ctx context.Context) error {
//				panic("mock out the Close method")
//			},
//			DelFunc: func(ctx context.Context, key []byte) error {
//				panic("mock out the Del method")
//			},
//			GetFunc: func(ctx context.Context, key []byte) (*store.CallbackData, error) {
//				panic("mock out the Get method")
//			},
//			GetManyFunc: func(ctx context.Context, keys [][]byte) ([]*store.CallbackData, error) {
//				panic("mock out the GetMany method")
//			},
//			GetRawTxsFunc: func(ctx context.Context, hashes [][]byte) ([][]byte, error) {
//				panic("mock out the GetRawTxs method")
//			},
//			GetSeenOnNetworkFunc: func(ctx context.Context, since time.Time, until time.Time, limit int64, offset int64) ([]*store.CallbackData, error) {
//				panic("mock out the GetSeenOnNetwork method")
//			},
//			GetStatsFunc: func(ctx context.Context, since time.Time, notSeenLimit time.Duration, notMinedLimit time.Duration) (*store.Stats, error) {
//				panic("mock out the GetStats method")
//			},
//			GetUnminedFunc: func(ctx context.Context, since time.Time, limit int64, offset int64) ([]*store.CallbackData, error) {
//				panic("mock out the GetUnmined method")
//			},
//			IncrementRetriesFunc: func(ctx context.Context, hash *chainhash.Hash) error {
//				panic("mock out the IncrementRetries method")
//			},
//			PingFunc: func(ctx context.Context) error {
//				panic("mock out the Ping method")
//			},
//			SetFunc: func(ctx context.Context, value *store.CallbackData) error {
//				panic("mock out the Set method")
//			},
//			SetBulkFunc: func(ctx context.Context, data []*store.CallbackData) error {
//				panic("mock out the SetBulk method")
//			},
//			SetLockedFunc: func(ctx context.Context, since time.Time, limit int64) error {
//				panic("mock out the SetLocked method")
//			},
//			SetUnlockedByNameFunc: func(ctx context.Context, lockedBy string) (int64, error) {
//				panic("mock out the SetUnlockedByName method")
//			},
//			SetUnlockedByNameExceptFunc: func(ctx context.Context, except []string) (int64, error) {
//				panic("mock out the SetUnlockedByNameExcept method")
//			},
//			UpdateDoubleSpendFunc: func(ctx context.Context, updates []store.UpdateStatus) ([]*store.CallbackData, error) {
//				panic("mock out the UpdateDoubleSpend method")
//			},
//			UpdateMinedFunc: func(ctx context.Context, txsBlocks []*blocktx_api.TransactionBlock) ([]*store.CallbackData, error) {
//				panic("mock out the UpdateMined method")
//			},
//			UpdateStatusBulkFunc: func(ctx context.Context, updates []store.UpdateStatus) ([]*store.CallbackData, error) {
//				panic("mock out the UpdateStatusBulk method")
//			},
//			UpdateStatusHistoryBulkFunc: func(ctx context.Context, updates []store.UpdateStatus) ([]*store.CallbackData, error) {
//				panic("mock out the UpdateStatusHistoryBulk method")
//			},
//		}
//
//		// use mockedCallbackerStore in code that requires store.CallbackerStore
//		// and then make assertions.
//
//	}
type CallbackerStoreMock struct {
	// ClearDataFunc mocks the ClearData method.
	ClearDataFunc func(ctx context.Context, retentionDays int32) (int64, error)

	// CloseFunc mocks the Close method.
	CloseFunc func(ctx context.Context) error

	// DelFunc mocks the Del method.
	DelFunc func(ctx context.Context, key []byte) error

	// GetRawTxsFunc mocks the GetRawTxs method.
	GetRawTxsFunc func(ctx context.Context, hashes [][]byte) ([][]byte, error)

	// IncrementRetriesFunc mocks the IncrementRetries method.
	IncrementRetriesFunc func(ctx context.Context, hash *chainhash.Hash) error

	// PingFunc mocks the Ping method.
	PingFunc func(ctx context.Context) error

	// SetLockedFunc mocks the SetLocked method.
	SetLockedFunc func(ctx context.Context, since time.Time, limit int64) error

	// SetUnlockedByNameFunc mocks the SetUnlockedByName method.
	SetUnlockedByNameFunc func(ctx context.Context, lockedBy string) (int64, error)

	// SetUnlockedByNameExceptFunc mocks the SetUnlockedByNameExcept method.
	SetUnlockedByNameExceptFunc func(ctx context.Context, except []string) (int64, error)

	// calls tracks calls to the methods.
	calls struct {
		// ClearData holds details about calls to the ClearData method.
		ClearData []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RetentionDays is the retentionDays argument value.
			RetentionDays int32
		}
		// Close holds details about calls to the Close method.
		Close []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Del holds details about calls to the Del method.
		Del []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key []byte
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key []byte
		}
		// GetMany holds details about calls to the GetMany method.
		GetMany []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys [][]byte
		}
		// GetRawTxs holds details about calls to the GetRawTxs method.
		GetRawTxs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hashes is the hashes argument value.
			Hashes [][]byte
		}
		// GetSeenOnNetwork holds details about calls to the GetSeenOnNetwork method.
		GetSeenOnNetwork []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Since is the since argument value.
			Since time.Time
			// Until is the until argument value.
			Until time.Time
			// Limit is the limit argument value.
			Limit int64
			// Offset is the offset argument value.
			Offset int64
		}
		// GetStats holds details about calls to the GetStats method.
		GetStats []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Since is the since argument value.
			Since time.Time
			// NotSeenLimit is the notSeenLimit argument value.
			NotSeenLimit time.Duration
			// NotMinedLimit is the notMinedLimit argument value.
			NotMinedLimit time.Duration
		}
		// GetUnmined holds details about calls to the GetUnmined method.
		GetUnmined []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Since is the since argument value.
			Since time.Time
			// Limit is the limit argument value.
			Limit int64
			// Offset is the offset argument value.
			Offset int64
		}
		// IncrementRetries holds details about calls to the IncrementRetries method.
		IncrementRetries []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash *chainhash.Hash
		}
		// Ping holds details about calls to the Ping method.
		Ping []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}

		// SetLocked holds details about calls to the SetLocked method.
		SetLocked []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Since is the since argument value.
			Since time.Time
			// Limit is the limit argument value.
			Limit int64
		}
		// SetUnlockedByName holds details about calls to the SetUnlockedByName method.
		SetUnlockedByName []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// LockedBy is the lockedBy argument value.
			LockedBy string
		}
		// SetUnlockedByNameExcept holds details about calls to the SetUnlockedByNameExcept method.
		SetUnlockedByNameExcept []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Except is the except argument value.
			Except []string
		}

		// UpdateMined holds details about calls to the UpdateMined method.
		UpdateMined []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxsBlocks is the txsBlocks argument value.
			TxsBlocks []*blocktx_api.TransactionBlock
		}
	}
	lockClearData               sync.RWMutex
	lockClose                   sync.RWMutex
	lockDel                     sync.RWMutex
	lockGet                     sync.RWMutex
	lockGetMany                 sync.RWMutex
	lockGetRawTxs               sync.RWMutex
	lockGetSeenOnNetwork        sync.RWMutex
	lockGetStats                sync.RWMutex
	lockGetUnmined              sync.RWMutex
	lockIncrementRetries        sync.RWMutex
	lockPing                    sync.RWMutex
	lockSet                     sync.RWMutex
	lockSetBulk                 sync.RWMutex
	lockSetLocked               sync.RWMutex
	lockSetUnlockedByName       sync.RWMutex
	lockSetUnlockedByNameExcept sync.RWMutex
	lockUpdateDoubleSpend       sync.RWMutex
	lockUpdateMined             sync.RWMutex
	lockUpdateStatusBulk        sync.RWMutex
	lockUpdateStatusHistoryBulk sync.RWMutex
}

func (mock *CallbackerStoreMock) Dispatch(url string, dto *callbacker.CallbackEntry) {
	//TODO implement me
	panic("implement me")
}

func (mock *CallbackerStoreMock) Get(ctx context.Context, key []byte) (*store.CallbackData, error) {
	//TODO implement me
	panic("implement me")
}

func (mock *CallbackerStoreMock) GetMany(ctx context.Context, keys [][]byte) ([]store.CallbackData, error) {
	//TODO implement me
	panic("implement me")
}

func (mock *CallbackerStoreMock) Set(ctx context.Context, value *store.CallbackData) error {
	//TODO implement me
	panic("implement me")
}

func (mock *CallbackerStoreMock) SetBulk(ctx context.Context, data []*store.CallbackData) error {
	//TODO implement me
	panic("implement me")
}

func (mock *CallbackerStoreMock) GetUnmined(ctx context.Context, since time.Time, limit int64, offset int64) ([]*store.CallbackData, error) {
	//TODO implement me
	panic("implement me")
}

func (mock *CallbackerStoreMock) GetSeenOnNetwork(ctx context.Context, since time.Time, until time.Time, limit int64, offset int64) ([]*store.CallbackData, error) {
	//TODO implement me
	panic("implement me")
}

func (mock *CallbackerStoreMock) UpdateStatusBulk(ctx context.Context, updates []store.UpdateStatus) ([]*store.CallbackData, error) {
	//TODO implement me
	panic("implement me")
}

func (mock *CallbackerStoreMock) UpdateStatusHistoryBulk(ctx context.Context, updates []store.UpdateStatus) (res []*store.CallbackData, err error) {
	//TODO implement me
	panic("implement me")
}

func (mock *CallbackerStoreMock) UpdateMined(ctx context.Context, txsBlocks []*blocktx_api.TransactionBlock) ([]*store.CallbackData, error) {
	//TODO implement me
	panic("implement me")
}

func (mock *CallbackerStoreMock) UpdateDoubleSpend(ctx context.Context, updates []store.UpdateStatus) ([]*store.CallbackData, error) {
	//TODO implement me
	panic("implement me")
}

func (mock *CallbackerStoreMock) GetStats(ctx context.Context, since time.Time, notSeenLimit time.Duration, notMinedLimit time.Duration) (*store.Stats, error) {
	//TODO implement me
	panic("implement me")
}

func (mock *CallbackerStoreMock) DeleteURLMappingsExcept(ctx context.Context, except []string) (rowsAffected int64, err error) {
	//TODO implement me
	panic("implement me")
}

// ClearData calls ClearDataFunc.
func (mock *CallbackerStoreMock) ClearData(ctx context.Context, retentionDays int32) (int64, error) {
	if mock.ClearDataFunc == nil {
		panic("CallbackerStoreMock.ClearDataFunc: method is nil but CallbackerStore.ClearData was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		RetentionDays int32
	}{
		Ctx:           ctx,
		RetentionDays: retentionDays,
	}
	mock.lockClearData.Lock()
	mock.calls.ClearData = append(mock.calls.ClearData, callInfo)
	mock.lockClearData.Unlock()
	return mock.ClearDataFunc(ctx, retentionDays)
}

// ClearDataCalls gets all the calls that were made to ClearData.
// Check the length with:
//
//	len(mockedCallbackerStore.ClearDataCalls())
func (mock *CallbackerStoreMock) ClearDataCalls() []struct {
	Ctx           context.Context
	RetentionDays int32
} {
	var calls []struct {
		Ctx           context.Context
		RetentionDays int32
	}
	mock.lockClearData.RLock()
	calls = mock.calls.ClearData
	mock.lockClearData.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *CallbackerStoreMock) Close(ctx context.Context) error {
	if mock.CloseFunc == nil {
		panic("CallbackerStoreMock.CloseFunc: method is nil but CallbackerStore.Close was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc(ctx)
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedCallbackerStore.CloseCalls())
func (mock *CallbackerStoreMock) CloseCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Del calls DelFunc.
func (mock *CallbackerStoreMock) Del(ctx context.Context, key []byte) error {
	if mock.DelFunc == nil {
		panic("CallbackerStoreMock.DelFunc: method is nil but CallbackerStore.Del was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key []byte
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockDel.Lock()
	mock.calls.Del = append(mock.calls.Del, callInfo)
	mock.lockDel.Unlock()
	return mock.DelFunc(ctx, key)
}

// DelCalls gets all the calls that were made to Del.
// Check the length with:
//
//	len(mockedCallbackerStore.DelCalls())
func (mock *CallbackerStoreMock) DelCalls() []struct {
	Ctx context.Context
	Key []byte
} {
	var calls []struct {
		Ctx context.Context
		Key []byte
	}
	mock.lockDel.RLock()
	calls = mock.calls.Del
	mock.lockDel.RUnlock()
	return calls
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedCallbackerStore.GetCalls())
func (mock *CallbackerStoreMock) GetCalls() []struct {
	Ctx context.Context
	Key []byte
} {
	var calls []struct {
		Ctx context.Context
		Key []byte
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// GetManyCalls gets all the calls that were made to GetMany.
// Check the length with:
//
//	len(mockedCallbackerStore.GetManyCalls())
func (mock *CallbackerStoreMock) GetManyCalls() []struct {
	Ctx  context.Context
	Keys [][]byte
} {
	var calls []struct {
		Ctx  context.Context
		Keys [][]byte
	}
	mock.lockGetMany.RLock()
	calls = mock.calls.GetMany
	mock.lockGetMany.RUnlock()
	return calls
}

// GetRawTxs calls GetRawTxsFunc.
func (mock *CallbackerStoreMock) GetRawTxs(ctx context.Context, hashes [][]byte) ([][]byte, error) {
	if mock.GetRawTxsFunc == nil {
		panic("CallbackerStoreMock.GetRawTxsFunc: method is nil but CallbackerStore.GetRawTxs was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Hashes [][]byte
	}{
		Ctx:    ctx,
		Hashes: hashes,
	}
	mock.lockGetRawTxs.Lock()
	mock.calls.GetRawTxs = append(mock.calls.GetRawTxs, callInfo)
	mock.lockGetRawTxs.Unlock()
	return mock.GetRawTxsFunc(ctx, hashes)
}

// GetRawTxsCalls gets all the calls that were made to GetRawTxs.
// Check the length with:
//
//	len(mockedCallbackerStore.GetRawTxsCalls())
func (mock *CallbackerStoreMock) GetRawTxsCalls() []struct {
	Ctx    context.Context
	Hashes [][]byte
} {
	var calls []struct {
		Ctx    context.Context
		Hashes [][]byte
	}
	mock.lockGetRawTxs.RLock()
	calls = mock.calls.GetRawTxs
	mock.lockGetRawTxs.RUnlock()
	return calls
}

// GetSeenOnNetworkCalls gets all the calls that were made to GetSeenOnNetwork.
// Check the length with:
//
//	len(mockedCallbackerStore.GetSeenOnNetworkCalls())
func (mock *CallbackerStoreMock) GetSeenOnNetworkCalls() []struct {
	Ctx    context.Context
	Since  time.Time
	Until  time.Time
	Limit  int64
	Offset int64
} {
	var calls []struct {
		Ctx    context.Context
		Since  time.Time
		Until  time.Time
		Limit  int64
		Offset int64
	}
	mock.lockGetSeenOnNetwork.RLock()
	calls = mock.calls.GetSeenOnNetwork
	mock.lockGetSeenOnNetwork.RUnlock()
	return calls
}

// GetStatsCalls gets all the calls that were made to GetStats.
// Check the length with:
//
//	len(mockedCallbackerStore.GetStatsCalls())
func (mock *CallbackerStoreMock) GetStatsCalls() []struct {
	Ctx           context.Context
	Since         time.Time
	NotSeenLimit  time.Duration
	NotMinedLimit time.Duration
} {
	var calls []struct {
		Ctx           context.Context
		Since         time.Time
		NotSeenLimit  time.Duration
		NotMinedLimit time.Duration
	}
	mock.lockGetStats.RLock()
	calls = mock.calls.GetStats
	mock.lockGetStats.RUnlock()
	return calls
}

// GetUnminedCalls gets all the calls that were made to GetUnmined.
// Check the length with:
//
//	len(mockedCallbackerStore.GetUnminedCalls())
func (mock *CallbackerStoreMock) GetUnminedCalls() []struct {
	Ctx    context.Context
	Since  time.Time
	Limit  int64
	Offset int64
} {
	var calls []struct {
		Ctx    context.Context
		Since  time.Time
		Limit  int64
		Offset int64
	}
	mock.lockGetUnmined.RLock()
	calls = mock.calls.GetUnmined
	mock.lockGetUnmined.RUnlock()
	return calls
}

// IncrementRetries calls IncrementRetriesFunc.
func (mock *CallbackerStoreMock) IncrementRetries(ctx context.Context, hash *chainhash.Hash) error {
	if mock.IncrementRetriesFunc == nil {
		panic("CallbackerStoreMock.IncrementRetriesFunc: method is nil but CallbackerStore.IncrementRetries was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hash *chainhash.Hash
	}{
		Ctx:  ctx,
		Hash: hash,
	}
	mock.lockIncrementRetries.Lock()
	mock.calls.IncrementRetries = append(mock.calls.IncrementRetries, callInfo)
	mock.lockIncrementRetries.Unlock()
	return mock.IncrementRetriesFunc(ctx, hash)
}

// IncrementRetriesCalls gets all the calls that were made to IncrementRetries.
// Check the length with:
//
//	len(mockedCallbackerStore.IncrementRetriesCalls())
func (mock *CallbackerStoreMock) IncrementRetriesCalls() []struct {
	Ctx  context.Context
	Hash *chainhash.Hash
} {
	var calls []struct {
		Ctx  context.Context
		Hash *chainhash.Hash
	}
	mock.lockIncrementRetries.RLock()
	calls = mock.calls.IncrementRetries
	mock.lockIncrementRetries.RUnlock()
	return calls
}

// Ping calls PingFunc.
func (mock *CallbackerStoreMock) Ping(ctx context.Context) error {
	if mock.PingFunc == nil {
		panic("CallbackerStoreMock.PingFunc: method is nil but CallbackerStore.Ping was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockPing.Lock()
	mock.calls.Ping = append(mock.calls.Ping, callInfo)
	mock.lockPing.Unlock()
	return mock.PingFunc(ctx)
}

// PingCalls gets all the calls that were made to Ping.
// Check the length with:
//
//	len(mockedCallbackerStore.PingCalls())
func (mock *CallbackerStoreMock) PingCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockPing.RLock()
	calls = mock.calls.Ping
	mock.lockPing.RUnlock()
	return calls
}

// SetLocked calls SetLockedFunc.
func (mock *CallbackerStoreMock) SetLocked(ctx context.Context, since time.Time, limit int64) error {
	if mock.SetLockedFunc == nil {
		panic("CallbackerStoreMock.SetLockedFunc: method is nil but CallbackerStore.SetLocked was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Since time.Time
		Limit int64
	}{
		Ctx:   ctx,
		Since: since,
		Limit: limit,
	}
	mock.lockSetLocked.Lock()
	mock.calls.SetLocked = append(mock.calls.SetLocked, callInfo)
	mock.lockSetLocked.Unlock()
	return mock.SetLockedFunc(ctx, since, limit)
}

// SetLockedCalls gets all the calls that were made to SetLocked.
// Check the length with:
//
//	len(mockedCallbackerStore.SetLockedCalls())
func (mock *CallbackerStoreMock) SetLockedCalls() []struct {
	Ctx   context.Context
	Since time.Time
	Limit int64
} {
	var calls []struct {
		Ctx   context.Context
		Since time.Time
		Limit int64
	}
	mock.lockSetLocked.RLock()
	calls = mock.calls.SetLocked
	mock.lockSetLocked.RUnlock()
	return calls
}

// SetUnlockedByName calls SetUnlockedByNameFunc.
func (mock *CallbackerStoreMock) SetUnlockedByName(ctx context.Context, lockedBy string) (int64, error) {
	if mock.SetUnlockedByNameFunc == nil {
		panic("CallbackerStoreMock.SetUnlockedByNameFunc: method is nil but CallbackerStore.SetUnlockedByName was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		LockedBy string
	}{
		Ctx:      ctx,
		LockedBy: lockedBy,
	}
	mock.lockSetUnlockedByName.Lock()
	mock.calls.SetUnlockedByName = append(mock.calls.SetUnlockedByName, callInfo)
	mock.lockSetUnlockedByName.Unlock()
	return mock.SetUnlockedByNameFunc(ctx, lockedBy)
}

// SetUnlockedByNameCalls gets all the calls that were made to SetUnlockedByName.
// Check the length with:
//
//	len(mockedCallbackerStore.SetUnlockedByNameCalls())
func (mock *CallbackerStoreMock) SetUnlockedByNameCalls() []struct {
	Ctx      context.Context
	LockedBy string
} {
	var calls []struct {
		Ctx      context.Context
		LockedBy string
	}
	mock.lockSetUnlockedByName.RLock()
	calls = mock.calls.SetUnlockedByName
	mock.lockSetUnlockedByName.RUnlock()
	return calls
}

// SetUnlockedByNameExcept calls SetUnlockedByNameExceptFunc.
func (mock *CallbackerStoreMock) SetUnlockedByNameExcept(ctx context.Context, except []string) (int64, error) {
	if mock.SetUnlockedByNameExceptFunc == nil {
		panic("CallbackerStoreMock.SetUnlockedByNameExceptFunc: method is nil but CallbackerStore.SetUnlockedByNameExcept was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Except []string
	}{
		Ctx:    ctx,
		Except: except,
	}
	mock.lockSetUnlockedByNameExcept.Lock()
	mock.calls.SetUnlockedByNameExcept = append(mock.calls.SetUnlockedByNameExcept, callInfo)
	mock.lockSetUnlockedByNameExcept.Unlock()
	return mock.SetUnlockedByNameExceptFunc(ctx, except)
}

// SetUnlockedByNameExceptCalls gets all the calls that were made to SetUnlockedByNameExcept.
// Check the length with:
//
//	len(mockedCallbackerStore.SetUnlockedByNameExceptCalls())
func (mock *CallbackerStoreMock) SetUnlockedByNameExceptCalls() []struct {
	Ctx    context.Context
	Except []string
} {
	var calls []struct {
		Ctx    context.Context
		Except []string
	}
	mock.lockSetUnlockedByNameExcept.RLock()
	calls = mock.calls.SetUnlockedByNameExcept
	mock.lockSetUnlockedByNameExcept.RUnlock()
	return calls
}

// UpdateMinedCalls gets all the calls that were made to UpdateMined.
// Check the length with:
//
//	len(mockedCallbackerStore.UpdateMinedCalls())
func (mock *CallbackerStoreMock) UpdateMinedCalls() []struct {
	Ctx       context.Context
	TxsBlocks []*blocktx_api.TransactionBlock
} {
	var calls []struct {
		Ctx       context.Context
		TxsBlocks []*blocktx_api.TransactionBlock
	}
	mock.lockUpdateMined.RLock()
	calls = mock.calls.UpdateMined
	mock.lockUpdateMined.RUnlock()
	return calls
}

// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/bitcoin-sv/arc/internal/metamorph"
	"github.com/bitcoin-sv/arc/internal/p2p"
	"sync"
)

// Ensure, that ProcessorIMock does implement metamorph.ProcessorI.
// If this is not the case, regenerate this file with moq.
var _ metamorph.ProcessorI = &ProcessorIMock{}

// ProcessorIMock is a mock implementation of metamorph.ProcessorI.
//
//	func TestSomethingThatUsesProcessorI(t *testing.T) {
//
//		// make and configure a mocked metamorph.ProcessorI
//		mockedProcessorI := &ProcessorIMock{
//			GetPeersFunc: func() []p2p.PeerI {
//				panic("mock out the GetPeers method")
//			},
//			GetProcessorMapSizeFunc: func() int {
//				panic("mock out the GetProcessorMapSize method")
//			},
//			HealthFunc: func() error {
//				panic("mock out the Health method")
//			},
//			ProcessTransactionFunc: func(ctx context.Context, req *metamorph.ProcessorRequest)  {
//				panic("mock out the ProcessTransaction method")
//			},
//		}
//
//		// use mockedProcessorI in code that requires metamorph.ProcessorI
//		// and then make assertions.
//
//	}
type ProcessorIMock struct {
	// GetPeersFunc mocks the GetPeers method.
	GetPeersFunc func() []p2p.PeerI

	// GetProcessorMapSizeFunc mocks the GetProcessorMapSize method.
	GetProcessorMapSizeFunc func() int

	// HealthFunc mocks the Health method.
	HealthFunc func() error

	// ProcessTransactionFunc mocks the ProcessTransaction method.
	ProcessTransactionFunc func(ctx context.Context, req *metamorph.ProcessorRequest)

	// calls tracks calls to the methods.
	calls struct {
		// GetPeers holds details about calls to the GetPeers method.
		GetPeers []struct {
		}
		// GetProcessorMapSize holds details about calls to the GetProcessorMapSize method.
		GetProcessorMapSize []struct {
		}
		// Health holds details about calls to the Health method.
		Health []struct {
		}
		// ProcessTransaction holds details about calls to the ProcessTransaction method.
		ProcessTransaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *metamorph.ProcessorRequest
		}
	}
	lockGetPeers            sync.RWMutex
	lockGetProcessorMapSize sync.RWMutex
	lockHealth              sync.RWMutex
	lockProcessTransaction  sync.RWMutex
}

// GetPeers calls GetPeersFunc.
func (mock *ProcessorIMock) GetPeers() []p2p.PeerI {
	if mock.GetPeersFunc == nil {
		panic("ProcessorIMock.GetPeersFunc: method is nil but ProcessorI.GetPeers was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetPeers.Lock()
	mock.calls.GetPeers = append(mock.calls.GetPeers, callInfo)
	mock.lockGetPeers.Unlock()
	return mock.GetPeersFunc()
}

// GetPeersCalls gets all the calls that were made to GetPeers.
// Check the length with:
//
//	len(mockedProcessorI.GetPeersCalls())
func (mock *ProcessorIMock) GetPeersCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetPeers.RLock()
	calls = mock.calls.GetPeers
	mock.lockGetPeers.RUnlock()
	return calls
}

// GetProcessorMapSize calls GetProcessorMapSizeFunc.
func (mock *ProcessorIMock) GetProcessorMapSize() int {
	if mock.GetProcessorMapSizeFunc == nil {
		panic("ProcessorIMock.GetProcessorMapSizeFunc: method is nil but ProcessorI.GetProcessorMapSize was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetProcessorMapSize.Lock()
	mock.calls.GetProcessorMapSize = append(mock.calls.GetProcessorMapSize, callInfo)
	mock.lockGetProcessorMapSize.Unlock()
	return mock.GetProcessorMapSizeFunc()
}

// GetProcessorMapSizeCalls gets all the calls that were made to GetProcessorMapSize.
// Check the length with:
//
//	len(mockedProcessorI.GetProcessorMapSizeCalls())
func (mock *ProcessorIMock) GetProcessorMapSizeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetProcessorMapSize.RLock()
	calls = mock.calls.GetProcessorMapSize
	mock.lockGetProcessorMapSize.RUnlock()
	return calls
}

// Health calls HealthFunc.
func (mock *ProcessorIMock) Health() error {
	if mock.HealthFunc == nil {
		panic("ProcessorIMock.HealthFunc: method is nil but ProcessorI.Health was just called")
	}
	callInfo := struct {
	}{}
	mock.lockHealth.Lock()
	mock.calls.Health = append(mock.calls.Health, callInfo)
	mock.lockHealth.Unlock()
	return mock.HealthFunc()
}

// HealthCalls gets all the calls that were made to Health.
// Check the length with:
//
//	len(mockedProcessorI.HealthCalls())
func (mock *ProcessorIMock) HealthCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHealth.RLock()
	calls = mock.calls.Health
	mock.lockHealth.RUnlock()
	return calls
}

// ProcessTransaction calls ProcessTransactionFunc.
func (mock *ProcessorIMock) ProcessTransaction(ctx context.Context, req *metamorph.ProcessorRequest) {
	if mock.ProcessTransactionFunc == nil {
		panic("ProcessorIMock.ProcessTransactionFunc: method is nil but ProcessorI.ProcessTransaction was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *metamorph.ProcessorRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockProcessTransaction.Lock()
	mock.calls.ProcessTransaction = append(mock.calls.ProcessTransaction, callInfo)
	mock.lockProcessTransaction.Unlock()
	mock.ProcessTransactionFunc(ctx, req)
}

// ProcessTransactionCalls gets all the calls that were made to ProcessTransaction.
// Check the length with:
//
//	len(mockedProcessorI.ProcessTransactionCalls())
func (mock *ProcessorIMock) ProcessTransactionCalls() []struct {
	Ctx context.Context
	Req *metamorph.ProcessorRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *metamorph.ProcessorRequest
	}
	mock.lockProcessTransaction.RLock()
	calls = mock.calls.ProcessTransaction
	mock.lockProcessTransaction.RUnlock()
	return calls
}

// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/bitcoin-sv/arc/internal/metamorph"
	sdkTx "github.com/bitcoin-sv/go-sdk/transaction"
	"sync"
)

// Ensure, that TransactionHandlerMock does implement metamorph.TransactionHandler.
// If this is not the case, regenerate this file with moq.
var _ metamorph.TransactionHandler = &TransactionHandlerMock{}

// TransactionHandlerMock is a mock implementation of metamorph.TransactionHandler.
//
//	func TestSomethingThatUsesTransactionHandler(t *testing.T) {
//
//		// make and configure a mocked metamorph.TransactionHandler
//		mockedTransactionHandler := &TransactionHandlerMock{
//			GetTransactionStatusFunc: func(ctx context.Context, txID string) (*metamorph.TransactionStatus, error) {
//				panic("mock out the GetTransactionStatus method")
//			},
//			GetTransactionStatusesFunc: func(ctx context.Context, txIDs []string) ([]*metamorph.TransactionStatus, error) {
//				panic("mock out the GetTransactionStatuses method")
//			},
//			GetTransactionsFunc: func(ctx context.Context, txIDs []string) ([]*metamorph.Transaction, error) {
//				panic("mock out the GetTransactions method")
//			},
//			HealthFunc: func(ctx context.Context) error {
//				panic("mock out the Health method")
//			},
//			SubmitTransactionFunc: func(ctx context.Context, tx *sdkTx.Transaction, options *metamorph.TransactionOptions) (*metamorph.TransactionStatus, error) {
//				panic("mock out the SubmitTransaction method")
//			},
//			SubmitTransactionsFunc: func(ctx context.Context, tx sdkTx.Transactions, options *metamorph.TransactionOptions) ([]*metamorph.TransactionStatus, error) {
//				panic("mock out the SubmitTransactions method")
//			},
//		}
//
//		// use mockedTransactionHandler in code that requires metamorph.TransactionHandler
//		// and then make assertions.
//
//	}
type TransactionHandlerMock struct {
	// GetTransactionStatusFunc mocks the GetTransactionStatus method.
	GetTransactionStatusFunc func(ctx context.Context, txID string) (*metamorph.TransactionStatus, error)

	// GetTransactionStatusesFunc mocks the GetTransactionStatuses method.
	GetTransactionStatusesFunc func(ctx context.Context, txIDs []string) ([]*metamorph.TransactionStatus, error)

	// GetTransactionsFunc mocks the GetTransactions method.
	GetTransactionsFunc func(ctx context.Context, txIDs []string) ([]*metamorph.Transaction, error)

	// HealthFunc mocks the Health method.
	HealthFunc func(ctx context.Context) error

	// SubmitTransactionFunc mocks the SubmitTransaction method.
	SubmitTransactionFunc func(ctx context.Context, tx *sdkTx.Transaction, options *metamorph.TransactionOptions) (*metamorph.TransactionStatus, error)

	// SubmitTransactionsFunc mocks the SubmitTransactions method.
	SubmitTransactionsFunc func(ctx context.Context, tx sdkTx.Transactions, options *metamorph.TransactionOptions) ([]*metamorph.TransactionStatus, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetTransactionStatus holds details about calls to the GetTransactionStatus method.
		GetTransactionStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxID is the txID argument value.
			TxID string
		}
		// GetTransactionStatuses holds details about calls to the GetTransactionStatuses method.
		GetTransactionStatuses []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxIDs is the txIDs argument value.
			TxIDs []string
		}
		// GetTransactions holds details about calls to the GetTransactions method.
		GetTransactions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TxIDs is the txIDs argument value.
			TxIDs []string
		}
		// Health holds details about calls to the Health method.
		Health []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// SubmitTransaction holds details about calls to the SubmitTransaction method.
		SubmitTransaction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx *sdkTx.Transaction
			// Options is the options argument value.
			Options *metamorph.TransactionOptions
		}
		// SubmitTransactions holds details about calls to the SubmitTransactions method.
		SubmitTransactions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx sdkTx.Transactions
			// Options is the options argument value.
			Options *metamorph.TransactionOptions
		}
	}
	lockGetTransactionStatus   sync.RWMutex
	lockGetTransactionStatuses sync.RWMutex
	lockGetTransactions        sync.RWMutex
	lockHealth                 sync.RWMutex
	lockSubmitTransaction      sync.RWMutex
	lockSubmitTransactions     sync.RWMutex
}

// GetTransactionStatus calls GetTransactionStatusFunc.
func (mock *TransactionHandlerMock) GetTransactionStatus(ctx context.Context, txID string) (*metamorph.TransactionStatus, error) {
	if mock.GetTransactionStatusFunc == nil {
		panic("TransactionHandlerMock.GetTransactionStatusFunc: method is nil but TransactionHandler.GetTransactionStatus was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		TxID string
	}{
		Ctx:  ctx,
		TxID: txID,
	}
	mock.lockGetTransactionStatus.Lock()
	mock.calls.GetTransactionStatus = append(mock.calls.GetTransactionStatus, callInfo)
	mock.lockGetTransactionStatus.Unlock()
	return mock.GetTransactionStatusFunc(ctx, txID)
}

// GetTransactionStatusCalls gets all the calls that were made to GetTransactionStatus.
// Check the length with:
//
//	len(mockedTransactionHandler.GetTransactionStatusCalls())
func (mock *TransactionHandlerMock) GetTransactionStatusCalls() []struct {
	Ctx  context.Context
	TxID string
} {
	var calls []struct {
		Ctx  context.Context
		TxID string
	}
	mock.lockGetTransactionStatus.RLock()
	calls = mock.calls.GetTransactionStatus
	mock.lockGetTransactionStatus.RUnlock()
	return calls
}

// GetTransactionStatuses calls GetTransactionStatusesFunc.
func (mock *TransactionHandlerMock) GetTransactionStatuses(ctx context.Context, txIDs []string) ([]*metamorph.TransactionStatus, error) {
	if mock.GetTransactionStatusesFunc == nil {
		panic("TransactionHandlerMock.GetTransactionStatusesFunc: method is nil but TransactionHandler.GetTransactionStatuses was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		TxIDs []string
	}{
		Ctx:   ctx,
		TxIDs: txIDs,
	}
	mock.lockGetTransactionStatuses.Lock()
	mock.calls.GetTransactionStatuses = append(mock.calls.GetTransactionStatuses, callInfo)
	mock.lockGetTransactionStatuses.Unlock()
	return mock.GetTransactionStatusesFunc(ctx, txIDs)
}

// GetTransactionStatusesCalls gets all the calls that were made to GetTransactionStatuses.
// Check the length with:
//
//	len(mockedTransactionHandler.GetTransactionStatusesCalls())
func (mock *TransactionHandlerMock) GetTransactionStatusesCalls() []struct {
	Ctx   context.Context
	TxIDs []string
} {
	var calls []struct {
		Ctx   context.Context
		TxIDs []string
	}
	mock.lockGetTransactionStatuses.RLock()
	calls = mock.calls.GetTransactionStatuses
	mock.lockGetTransactionStatuses.RUnlock()
	return calls
}

// GetTransactions calls GetTransactionsFunc.
func (mock *TransactionHandlerMock) GetTransactions(ctx context.Context, txIDs []string) ([]*metamorph.Transaction, error) {
	if mock.GetTransactionsFunc == nil {
		panic("TransactionHandlerMock.GetTransactionsFunc: method is nil but TransactionHandler.GetTransactions was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		TxIDs []string
	}{
		Ctx:   ctx,
		TxIDs: txIDs,
	}
	mock.lockGetTransactions.Lock()
	mock.calls.GetTransactions = append(mock.calls.GetTransactions, callInfo)
	mock.lockGetTransactions.Unlock()
	return mock.GetTransactionsFunc(ctx, txIDs)
}

// GetTransactionsCalls gets all the calls that were made to GetTransactions.
// Check the length with:
//
//	len(mockedTransactionHandler.GetTransactionsCalls())
func (mock *TransactionHandlerMock) GetTransactionsCalls() []struct {
	Ctx   context.Context
	TxIDs []string
} {
	var calls []struct {
		Ctx   context.Context
		TxIDs []string
	}
	mock.lockGetTransactions.RLock()
	calls = mock.calls.GetTransactions
	mock.lockGetTransactions.RUnlock()
	return calls
}

// Health calls HealthFunc.
func (mock *TransactionHandlerMock) Health(ctx context.Context) error {
	if mock.HealthFunc == nil {
		panic("TransactionHandlerMock.HealthFunc: method is nil but TransactionHandler.Health was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockHealth.Lock()
	mock.calls.Health = append(mock.calls.Health, callInfo)
	mock.lockHealth.Unlock()
	return mock.HealthFunc(ctx)
}

// HealthCalls gets all the calls that were made to Health.
// Check the length with:
//
//	len(mockedTransactionHandler.HealthCalls())
func (mock *TransactionHandlerMock) HealthCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockHealth.RLock()
	calls = mock.calls.Health
	mock.lockHealth.RUnlock()
	return calls
}

// SubmitTransaction calls SubmitTransactionFunc.
func (mock *TransactionHandlerMock) SubmitTransaction(ctx context.Context, tx *sdkTx.Transaction, options *metamorph.TransactionOptions) (*metamorph.TransactionStatus, error) {
	if mock.SubmitTransactionFunc == nil {
		panic("TransactionHandlerMock.SubmitTransactionFunc: method is nil but TransactionHandler.SubmitTransaction was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Tx      *sdkTx.Transaction
		Options *metamorph.TransactionOptions
	}{
		Ctx:     ctx,
		Tx:      tx,
		Options: options,
	}
	mock.lockSubmitTransaction.Lock()
	mock.calls.SubmitTransaction = append(mock.calls.SubmitTransaction, callInfo)
	mock.lockSubmitTransaction.Unlock()
	return mock.SubmitTransactionFunc(ctx, tx, options)
}

// SubmitTransactionCalls gets all the calls that were made to SubmitTransaction.
// Check the length with:
//
//	len(mockedTransactionHandler.SubmitTransactionCalls())
func (mock *TransactionHandlerMock) SubmitTransactionCalls() []struct {
	Ctx     context.Context
	Tx      *sdkTx.Transaction
	Options *metamorph.TransactionOptions
} {
	var calls []struct {
		Ctx     context.Context
		Tx      *sdkTx.Transaction
		Options *metamorph.TransactionOptions
	}
	mock.lockSubmitTransaction.RLock()
	calls = mock.calls.SubmitTransaction
	mock.lockSubmitTransaction.RUnlock()
	return calls
}

// SubmitTransactions calls SubmitTransactionsFunc.
func (mock *TransactionHandlerMock) SubmitTransactions(ctx context.Context, tx sdkTx.Transactions, options *metamorph.TransactionOptions) ([]*metamorph.TransactionStatus, error) {
	if mock.SubmitTransactionsFunc == nil {
		panic("TransactionHandlerMock.SubmitTransactionsFunc: method is nil but TransactionHandler.SubmitTransactions was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Tx      sdkTx.Transactions
		Options *metamorph.TransactionOptions
	}{
		Ctx:     ctx,
		Tx:      tx,
		Options: options,
	}
	mock.lockSubmitTransactions.Lock()
	mock.calls.SubmitTransactions = append(mock.calls.SubmitTransactions, callInfo)
	mock.lockSubmitTransactions.Unlock()
	return mock.SubmitTransactionsFunc(ctx, tx, options)
}

// SubmitTransactionsCalls gets all the calls that were made to SubmitTransactions.
// Check the length with:
//
//	len(mockedTransactionHandler.SubmitTransactionsCalls())
func (mock *TransactionHandlerMock) SubmitTransactionsCalls() []struct {
	Ctx     context.Context
	Tx      sdkTx.Transactions
	Options *metamorph.TransactionOptions
} {
	var calls []struct {
		Ctx     context.Context
		Tx      sdkTx.Transactions
		Options *metamorph.TransactionOptions
	}
	mock.lockSubmitTransactions.RLock()
	calls = mock.calls.SubmitTransactions
	mock.lockSubmitTransactions.RUnlock()
	return calls
}

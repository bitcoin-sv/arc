// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/bitcoin-sv/arc/internal/multicast"
	"github.com/libsv/go-p2p/wire"
	"sync"
)

// Ensure, that MessageHandlerIMock does implement multicast.MessageHandlerI.
// If this is not the case, regenerate this file with moq.
var _ multicast.MessageHandlerI = &MessageHandlerIMock{}

// MessageHandlerIMock is a mock implementation of multicast.MessageHandlerI.
//
//	func TestSomethingThatUsesMessageHandlerI(t *testing.T) {
//
//		// make and configure a mocked multicast.MessageHandlerI
//		mockedMessageHandlerI := &MessageHandlerIMock{
//			OnReceiveFromMcastFunc: func(msg wire.Message)  {
//				panic("mock out the OnReceiveFromMcast method")
//			},
//			OnSendToMcastFunc: func(msg wire.Message)  {
//				panic("mock out the OnSendToMcast method")
//			},
//		}
//
//		// use mockedMessageHandlerI in code that requires multicast.MessageHandlerI
//		// and then make assertions.
//
//	}
type MessageHandlerIMock struct {
	// OnReceiveFromMcastFunc mocks the OnReceiveFromMcast method.
	OnReceiveFromMcastFunc func(msg wire.Message)

	// OnSendToMcastFunc mocks the OnSendToMcast method.
	OnSendToMcastFunc func(msg wire.Message)

	// calls tracks calls to the methods.
	calls struct {
		// OnReceiveFromMcast holds details about calls to the OnReceiveFromMcast method.
		OnReceiveFromMcast []struct {
			// Msg is the msg argument value.
			Msg wire.Message
		}
		// OnSendToMcast holds details about calls to the OnSendToMcast method.
		OnSendToMcast []struct {
			// Msg is the msg argument value.
			Msg wire.Message
		}
	}
	lockOnReceiveFromMcast sync.RWMutex
	lockOnSendToMcast      sync.RWMutex
}

// OnReceiveFromMcast calls OnReceiveFromMcastFunc.
func (mock *MessageHandlerIMock) OnReceiveFromMcast(msg wire.Message) {
	if mock.OnReceiveFromMcastFunc == nil {
		panic("MessageHandlerIMock.OnReceiveFromMcastFunc: method is nil but MessageHandlerI.OnReceiveFromMcast was just called")
	}
	callInfo := struct {
		Msg wire.Message
	}{
		Msg: msg,
	}
	mock.lockOnReceiveFromMcast.Lock()
	mock.calls.OnReceiveFromMcast = append(mock.calls.OnReceiveFromMcast, callInfo)
	mock.lockOnReceiveFromMcast.Unlock()
	mock.OnReceiveFromMcastFunc(msg)
}

// OnReceiveFromMcastCalls gets all the calls that were made to OnReceiveFromMcast.
// Check the length with:
//
//	len(mockedMessageHandlerI.OnReceiveFromMcastCalls())
func (mock *MessageHandlerIMock) OnReceiveFromMcastCalls() []struct {
	Msg wire.Message
} {
	var calls []struct {
		Msg wire.Message
	}
	mock.lockOnReceiveFromMcast.RLock()
	calls = mock.calls.OnReceiveFromMcast
	mock.lockOnReceiveFromMcast.RUnlock()
	return calls
}

// OnSendToMcast calls OnSendToMcastFunc.
func (mock *MessageHandlerIMock) OnSendToMcast(msg wire.Message) {
	if mock.OnSendToMcastFunc == nil {
		panic("MessageHandlerIMock.OnSendToMcastFunc: method is nil but MessageHandlerI.OnSendToMcast was just called")
	}
	callInfo := struct {
		Msg wire.Message
	}{
		Msg: msg,
	}
	mock.lockOnSendToMcast.Lock()
	mock.calls.OnSendToMcast = append(mock.calls.OnSendToMcast, callInfo)
	mock.lockOnSendToMcast.Unlock()
	mock.OnSendToMcastFunc(msg)
}

// OnSendToMcastCalls gets all the calls that were made to OnSendToMcast.
// Check the length with:
//
//	len(mockedMessageHandlerI.OnSendToMcastCalls())
func (mock *MessageHandlerIMock) OnSendToMcastCalls() []struct {
	Msg wire.Message
} {
	var calls []struct {
		Msg wire.Message
	}
	mock.lockOnSendToMcast.RLock()
	calls = mock.calls.OnSendToMcast
	mock.lockOnSendToMcast.RUnlock()
	return calls
}

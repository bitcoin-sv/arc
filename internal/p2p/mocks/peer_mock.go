// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/bitcoin-sv/arc/internal/p2p"
	"github.com/libsv/go-p2p/wire"
	"sync"
)

// Ensure, that PeerIMock does implement p2p.PeerI.
// If this is not the case, regenerate this file with moq.
var _ p2p.PeerI = &PeerIMock{}

// PeerIMock is a mock implementation of p2p.PeerI.
//
//	func TestSomethingThatUsesPeerI(t *testing.T) {
//
//		// make and configure a mocked p2p.PeerI
//		mockedPeerI := &PeerIMock{
//			ConnectedFunc: func() bool {
//				panic("mock out the Connected method")
//			},
//			IsUnhealthyChFunc: func() <-chan struct{} {
//				panic("mock out the IsUnhealthyCh method")
//			},
//			NetworkFunc: func() wire.BitcoinNet {
//				panic("mock out the Network method")
//			},
//			RestartFunc: func() bool {
//				panic("mock out the Restart method")
//			},
//			ShutdownFunc: func()  {
//				panic("mock out the Shutdown method")
//			},
//			StringFunc: func() string {
//				panic("mock out the String method")
//			},
//			WriteMsgFunc: func(msg wire.Message)  {
//				panic("mock out the WriteMsg method")
//			},
//		}
//
//		// use mockedPeerI in code that requires p2p.PeerI
//		// and then make assertions.
//
//	}
type PeerIMock struct {
	// ConnectedFunc mocks the Connected method.
	ConnectedFunc func() bool

	// IsUnhealthyChFunc mocks the IsUnhealthyCh method.
	IsUnhealthyChFunc func() <-chan struct{}

	// NetworkFunc mocks the Network method.
	NetworkFunc func() wire.BitcoinNet

	// RestartFunc mocks the Restart method.
	RestartFunc func() bool

	// ShutdownFunc mocks the Shutdown method.
	ShutdownFunc func()

	// StringFunc mocks the String method.
	StringFunc func() string

	// WriteMsgFunc mocks the WriteMsg method.
	WriteMsgFunc func(msg wire.Message)

	// calls tracks calls to the methods.
	calls struct {
		// Connected holds details about calls to the Connected method.
		Connected []struct {
		}
		// IsUnhealthyCh holds details about calls to the IsUnhealthyCh method.
		IsUnhealthyCh []struct {
		}
		// Network holds details about calls to the Network method.
		Network []struct {
		}
		// Restart holds details about calls to the Restart method.
		Restart []struct {
		}
		// Shutdown holds details about calls to the Shutdown method.
		Shutdown []struct {
		}
		// String holds details about calls to the String method.
		String []struct {
		}
		// WriteMsg holds details about calls to the WriteMsg method.
		WriteMsg []struct {
			// Msg is the msg argument value.
			Msg wire.Message
		}
	}
	lockConnected     sync.RWMutex
	lockIsUnhealthyCh sync.RWMutex
	lockNetwork       sync.RWMutex
	lockRestart       sync.RWMutex
	lockShutdown      sync.RWMutex
	lockString        sync.RWMutex
	lockWriteMsg      sync.RWMutex
}

// Connected calls ConnectedFunc.
func (mock *PeerIMock) Connected() bool {
	if mock.ConnectedFunc == nil {
		panic("PeerIMock.ConnectedFunc: method is nil but PeerI.Connected was just called")
	}
	callInfo := struct {
	}{}
	mock.lockConnected.Lock()
	mock.calls.Connected = append(mock.calls.Connected, callInfo)
	mock.lockConnected.Unlock()
	return mock.ConnectedFunc()
}

// ConnectedCalls gets all the calls that were made to Connected.
// Check the length with:
//
//	len(mockedPeerI.ConnectedCalls())
func (mock *PeerIMock) ConnectedCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockConnected.RLock()
	calls = mock.calls.Connected
	mock.lockConnected.RUnlock()
	return calls
}

// IsUnhealthyCh calls IsUnhealthyChFunc.
func (mock *PeerIMock) IsUnhealthyCh() <-chan struct{} {
	if mock.IsUnhealthyChFunc == nil {
		panic("PeerIMock.IsUnhealthyChFunc: method is nil but PeerI.IsUnhealthyCh was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsUnhealthyCh.Lock()
	mock.calls.IsUnhealthyCh = append(mock.calls.IsUnhealthyCh, callInfo)
	mock.lockIsUnhealthyCh.Unlock()
	return mock.IsUnhealthyChFunc()
}

// IsUnhealthyChCalls gets all the calls that were made to IsUnhealthyCh.
// Check the length with:
//
//	len(mockedPeerI.IsUnhealthyChCalls())
func (mock *PeerIMock) IsUnhealthyChCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsUnhealthyCh.RLock()
	calls = mock.calls.IsUnhealthyCh
	mock.lockIsUnhealthyCh.RUnlock()
	return calls
}

// Network calls NetworkFunc.
func (mock *PeerIMock) Network() wire.BitcoinNet {
	if mock.NetworkFunc == nil {
		panic("PeerIMock.NetworkFunc: method is nil but PeerI.Network was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNetwork.Lock()
	mock.calls.Network = append(mock.calls.Network, callInfo)
	mock.lockNetwork.Unlock()
	return mock.NetworkFunc()
}

// NetworkCalls gets all the calls that were made to Network.
// Check the length with:
//
//	len(mockedPeerI.NetworkCalls())
func (mock *PeerIMock) NetworkCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNetwork.RLock()
	calls = mock.calls.Network
	mock.lockNetwork.RUnlock()
	return calls
}

// Restart calls RestartFunc.
func (mock *PeerIMock) Restart() bool {
	if mock.RestartFunc == nil {
		panic("PeerIMock.RestartFunc: method is nil but PeerI.Restart was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRestart.Lock()
	mock.calls.Restart = append(mock.calls.Restart, callInfo)
	mock.lockRestart.Unlock()
	return mock.RestartFunc()
}

// RestartCalls gets all the calls that were made to Restart.
// Check the length with:
//
//	len(mockedPeerI.RestartCalls())
func (mock *PeerIMock) RestartCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRestart.RLock()
	calls = mock.calls.Restart
	mock.lockRestart.RUnlock()
	return calls
}

// Shutdown calls ShutdownFunc.
func (mock *PeerIMock) Shutdown() {
	if mock.ShutdownFunc == nil {
		panic("PeerIMock.ShutdownFunc: method is nil but PeerI.Shutdown was just called")
	}
	callInfo := struct {
	}{}
	mock.lockShutdown.Lock()
	mock.calls.Shutdown = append(mock.calls.Shutdown, callInfo)
	mock.lockShutdown.Unlock()
	mock.ShutdownFunc()
}

// ShutdownCalls gets all the calls that were made to Shutdown.
// Check the length with:
//
//	len(mockedPeerI.ShutdownCalls())
func (mock *PeerIMock) ShutdownCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockShutdown.RLock()
	calls = mock.calls.Shutdown
	mock.lockShutdown.RUnlock()
	return calls
}

// String calls StringFunc.
func (mock *PeerIMock) String() string {
	if mock.StringFunc == nil {
		panic("PeerIMock.StringFunc: method is nil but PeerI.String was just called")
	}
	callInfo := struct {
	}{}
	mock.lockString.Lock()
	mock.calls.String = append(mock.calls.String, callInfo)
	mock.lockString.Unlock()
	return mock.StringFunc()
}

// StringCalls gets all the calls that were made to String.
// Check the length with:
//
//	len(mockedPeerI.StringCalls())
func (mock *PeerIMock) StringCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockString.RLock()
	calls = mock.calls.String
	mock.lockString.RUnlock()
	return calls
}

// WriteMsg calls WriteMsgFunc.
func (mock *PeerIMock) WriteMsg(msg wire.Message) {
	if mock.WriteMsgFunc == nil {
		panic("PeerIMock.WriteMsgFunc: method is nil but PeerI.WriteMsg was just called")
	}
	callInfo := struct {
		Msg wire.Message
	}{
		Msg: msg,
	}
	mock.lockWriteMsg.Lock()
	mock.calls.WriteMsg = append(mock.calls.WriteMsg, callInfo)
	mock.lockWriteMsg.Unlock()
	mock.WriteMsgFunc(msg)
}

// WriteMsgCalls gets all the calls that were made to WriteMsg.
// Check the length with:
//
//	len(mockedPeerI.WriteMsgCalls())
func (mock *PeerIMock) WriteMsgCalls() []struct {
	Msg wire.Message
} {
	var calls []struct {
		Msg wire.Message
	}
	mock.lockWriteMsg.RLock()
	calls = mock.calls.WriteMsg
	mock.lockWriteMsg.RUnlock()
	return calls
}
